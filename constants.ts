import { Article, NavItem } from './types';

export const NAV_ITEMS: NavItem[] = [
  { label: 'Articles', href: '#articles' },
  { label: 'Projects', href: 'https://github.com/mohamed-amine-melliti' },
  { label: 'Speaking', href: '#speaking' },
  { label: 'About', href: '/about' },
];

export const MOCK_ARTICLES: Article[] = [
  {
    id: '5',
    category: 'الرؤية الحاسوبية',
    title: 'تعلم الرؤية الحاسوبية: دمج OpenCV مع التعلم العميق',
    author: 'MAM',
    date: '18 فبراير 2025',
    imageUrl: 'https://images.unsplash.com/photo-1550751827-4bd374c3f58b?q=80&w=1600&auto=format&fit=crop',
    description: 'استكشاف شامل لكيفية الانتقال من معالجة الصور التقليدية إلى الشبكات العصبية العميقة (CNNs) باستخدام كتاب Sunila Gollapudi.',
    themeColor: '#F59E0B',
    content: `
      <p class="lead">الرؤية الحاسوبية (Computer Vision) لم تعد مجرد تلاعب بالبكسلات؛ إنها الآن عيون الذكاء الاصطناعي. يقدم كتاب <em>"Learn Computer Vision Using OpenCV"</em> للمؤلفة Sunila Gollapudi خارطة طريق أساسية للمطورين الذين يرغبون في الانتقال من الأساسيات إلى الشبكات العصبية المتقدمة.</p>
      
      <h2>لماذا هذا الكتاب؟</h2>
      <p>في عالم مليء بمكتبات "الصندوق الأسود" التي تخفي التعقيدات، يبرز هذا الكتاب لأنه يبني الفهم من الأسفل إلى الأعلى. يبدأ بأساسيات مكتبة OpenCV 4 — المعيار الصناعي لمعالجة الصور — ثم يدمجها بسلاسة مع مكتبات التعلم العميق مثل TensorFlow و Keras.</p>
      
      <h2>ما ستتعلمه</h2>
      <ul>
        <li><strong>المعالجة الكلاسيكية:</strong> التعامل مع الصور، اكتشاف الحواف، والتحويلات الهندسية وفلترة الصور. هذه الأساسيات ضرورية لتنظيف البيانات قبل تغذيتها للنماذج.</li>
        <li><strong>التعلم الآلي في الرؤية:</strong> استخدام خوارزميات ML التقليدية (مثل SVMs و k-means) لتصنيف الصور وتجزئتها.</li>
        <li><strong>الشبكات العصبية التلافيفية (CNNs):</strong> القلب النابض للرؤية الحديثة. يشرح الكتاب كيفية بناء وتدريب CNNs لاكتشاف الكائنات وتصنيفها بدقة تفوق البشر.</li>
        <li><strong>الشبكات العصبية المتكررة (RNNs):</strong> التعامل مع البيانات المتسلسلة مثل الفيديو، وهو مجال غالبًا ما يتم تجاهله في كتب المبتدئين.</li>
      </ul>

      <h2>التطبيق العملي: OpenCV + Deep Learning</h2>
      <p>أحد أقوى جوانب الكتاب هو التركيز على التطبيق العملي. يوضح كيف يمكنك استخدام OpenCV ليس فقط للمعالجة المسبقة، ولكن كإطار عمل متكامل لنشر النماذج. على سبيل المثال، يغطي كيفية تحميل نماذج مدربة مسبقًا (Pre-trained models) وتشغيلها بكفاءة على الأجهزة الطرفية.</p>

      <pre><code># مثال بسيط لتحميل صورة ومعالجتها
import cv2
import numpy as np

img = cv2.imread('image.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
edges = cv2.Canny(gray, 100, 200)

cv2.imshow('Edges', edges)
cv2.waitKey(0)</code></pre>
      
      <h2>الخلاصة</h2>
      <p>إذا كنت مهندس برمجيات تتطلع إلى بناء أنظمة ترى العالم وتفهمه، فإن الدمج بين سرعة OpenCV ودقة التعلم العميق هو مهارة لا غنى عنها. هذا الكتاب هو دليلك لردم الفجوة بين النظرية والتطبيق.</p>
    `
  },
  {
    id: '1',
    category: 'الذكاء الاصطناعي',
    title: 'صعود سير العمل الوكيل في تطبيقات الويب',
    author: 'MAM',
    date: '12 فبراير 2025',
    imageUrl: 'https://images.unsplash.com/photo-1620712943543-bcc4688e7485?q=80&w=800&auto=format&fit=crop',
    description: 'كيف تنتقل وكلاء الذكاء الاصطناعي المستقلة إلى ما هو أبعد من روبوتات الدردشة لتنفيذ مهام معقدة داخل المتصفح.',
    themeColor: '#D92F27',
    content: `
      <p class="lead">عصر "الدردشة" مع الذكاء الاصطناعي يتطور إلى "العمل" مع الذكاء الاصطناعي. تمثل سير العمل الوكيل (Agentic Workflows) النقلة النوعية التالية في كيفية دمج نماذج اللغة الكبيرة (LLMs) في تطبيقات الويب.</p>
      
      <h2>ما وراء واجهة الدردشة</h2>
      <p>على مدار العامين الماضيين، كانت واجهة المستخدم المهيمنة للذكاء الاصطناعي هي نافذة الدردشة. وفي حين أنها فعالة لاسترجاع المعلومات، إلا أنها تشكل عنق زجاجة لتنفيذ المهام المعقدة. الوكلاء، على عكس روبوتات الدردشة البسيطة، مصممون للإدراك، والتفكير، والتصرف.</p>
      <p>في سياق الويب، قد يتضمن سير العمل الوكيل ما يلي:</p>
      <ul>
        <li><strong>التخطيط:</strong> تقسيم هدف المستخدم (مثل "حجز رحلة طيران وفندق") إلى مهام فرعية.</li>
        <li><strong>استخدام الأدوات:</strong> التفاعل مع واجهات برمجة التطبيقات (Skyscanner، Airbnb) لجلب البيانات في الوقت الفعلي.</li>
        <li><strong>التأمل:</strong> التحقق مما إذا كانت البيانات المستردة تلبي قيود المستخدم قبل تقديمها.</li>
      </ul>

      <h2>التنفيذ الفني في React</h2>
      <p>يتطلب تنفيذ مسارات العمل هذه تحولاً في إدارة الحالة. بدلاً من دورات الطلب/الاستجابة البسيطة، نحتاج إلى إدارة سجل المحادثات، ومخرجات الأدوات، وخطوات التفكير الوسيطة.</p>
      <pre><code>// كود وهمي لحلقة وكيل بسيطة
async function runAgent(goal) {
  let context = [goal];
  while (!isComplete(context)) {
    const step = await llm.decideNextStep(context);
    if (step.action === 'call_tool') {
      const result = await executeTool(step.tool, step.args);
      context.push(result);
    } else {
      return step.response;
    }
  }
}</code></pre>
      
      <h2>المستقبل ذاتي التحكم</h2>
      <p>مع تزايد سرعة النماذج وانخفاض تكلفتها، سنرى وكلاء يعملون في خلفية متصفحاتنا، يقومون بجلب المحتوى مسبقاً، وتحسين التخطيطات، وأتمتة النماذج المتكررة. يتحول دور مطور الويب من بناء واجهات ثابتة إلى تصميم البيئات التي يعمل فيها هؤلاء الوكلاء.</p>
    `
  },
  {
    id: '2',
    category: 'تطوير الويب',
    title: 'مكونات خادم React: نقلة نوعية',
    author: 'MAM',
    date: '28 يناير 2025',
    imageUrl: 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?q=80&w=800&auto=format&fit=crop',
    description: 'فهم الآثار المعمارية لمكونات خادم React وكيف تعيد تعريف الحدود بين العميل والخادم.',
    themeColor: '#2563EB',
    content: `
      <p>مكونات خادم React (RSC) ليست مجرد ميزة جديدة؛ إنها إعادة تفكير جوهرية في كيفية شحن التطبيقات إلى المتصفح. من خلال السماح للمكونات بالتقديم حصرياً على الخادم، يمكننا تقليل حجم حزمة JavaScript المرسلة إلى العميل بشكل كبير.</p>

      <h2>حلم الحزمة الصفرية</h2>
      <p>تقليدياً، إذا أردت استخدام مكتبة مثل <code>date-fns</code> أو محلل markdown، كان عليك شحن هذا الكود إلى متصفح المستخدم. مع RSC، إذا تم تقديم مكون على الخادم، فإن تبعياته تظل على الخادم. يتلقى العميل فقط HTML المقدم.</p>

      <h2>تبسيط جلب البيانات</h2>
      <p>تنقل RSC عملية جلب البيانات لتصبح أقرب إلى المصدر. بدلاً من خطافات <code>useEffect</code> ومؤشرات التحميل، يمكنك استخدام المكونات غير المتزامنة (async components) لجلب البيانات مباشرة من قاعدة البيانات الخاصة بك.</p>
      
      <h2>متى نستخدم مكونات العميل؟</h2>
      <p>لا يمكن أن تحتوي مكونات الخادم على تفاعلية (حالة، تأثيرات، مستمعي أحداث). هذا يفرض فصلاً واضحاً للاهتمامات:</p>
      <ul>
        <li><strong>مكونات الخادم:</strong> جلب البيانات، التخطيط، المحتوى الثابت.</li>
        <li><strong>مكونات العميل:</strong> الأزرار، المدخلات، الأدوات التفاعلية.</li>
      </ul>
      <p>يسمح لنا هذا النموذج الهجين بالحصول على أفضل ما في العالمين: أداء العرض من جانب الخادم مع التفاعلية الغنية لـ React من جانب العميل.</p>
    `
  },
  {
    id: '3',
    category: 'هندسة النماذج اللغوية',
    title: 'RAG مقابل نوافذ السياق الطويلة: اتخاذ القرار الصحيح',
    author: 'MAM',
    date: '15 يناير 2025',
    imageUrl: 'https://images.unsplash.com/photo-1677442136019-21780ecad995?q=80&w=800&auto=format&fit=crop',
    description: 'تحليل مقايضات التكلفة والكمون والدقة عند بناء تطبيقات الذكاء الاصطناعي كثيفة المعرفة.',
    themeColor: '#059669',
    content: `
      <p>مع إصدار Gemini 1.5 Pro ونافذة السياق الضخمة الخاصة به، يتساءل المطورون: "هل ما زلنا بحاجة إلى الاسترجاع المعزز بالتوليد (RAG)؟" الإجابة دقيقة.</p>

      <h2>قضية السياق الطويل</h2>
      <p>إن تغذية الوثائق الكاملة في الموجه (prompt) أمر قوي للغاية. فهو يسمح للنموذج بإجراء تفكير عالمي عبر مجموعة البيانات بأكملها، والعثور على روابط قد يفوتها نظام الاسترجاع القائم على الأجزاء. إنه يبسط البنية بشكل كبير—لا حاجة لقاعدة بيانات متجهة، ولا خط أنابيب للتضمين.</p>

      <h2>قضية RAG</h2>
      <p>ومع ذلك، لا يزال RAG يسود في سيناريوهات محددة:</p>
      <ul>
        <li><strong>الكمون (Latency):</strong> معالجة مليون رمز تستغرق وقتاً. استرجاع 5 أجزاء ذات صلة ومعالجة 2000 رمز يتم بشكل شبه فوري.</li>
        <li><strong>التكلفة:</strong> رموز الإدخال تكلف مالاً. إرسال نافذة سياق ضخمة بشكل متكرر لكل استعلام أمر مكلف.</li>
        <li><strong>البيانات الديناميكية:</strong> إذا كانت بياناتك تتغير كل دقيقة، فإن تحديث الفهرس المتجه غالباً ما يكون أكثر كفاءة من إعادة تخزين السياق مؤقتاً.</li>
      </ul>

      <h2>مناهج هجينة</h2>
      <p>غالباً ما تستخدم الأنظمة الأكثر قوة اليوم نهجاً هجيناً: استخدام RAG لتضييق مساحة البحث إلى سياق "متوسط" (على سبيل المثال، 50 ألف رمز) والسماح للنموذج بالتفكير بعمق في تلك المجموعة الفرعية.</p>
    `
  },
  {
    id: '4',
    category: 'أداء الواجهة الأمامية',
    title: 'تحسين مؤشرات الويب الحيوية في 2025',
    author: 'MAM',
    date: '22 ديسمبر 2024',
    imageUrl: 'https://images.unsplash.com/photo-1551288049-bebda4e38f71?q=80&w=800&auto=format&fit=crop',
    description: 'تقنيات متقدمة لتقليل INP و LCP في تطبيقات الصفحة الواحدة المعقدة.',
    themeColor: '#7C3AED',
    content: `
      <p>أصبحت مؤشرات الويب الحيوية (Core Web Vitals) المعيار الذهبي لقياس تجربة المستخدم. في عام 2025، تحول التركيز بشكل كبير نحو التفاعل للرسم التالي (INP)، ليحل محل FID.</p>

      <h2>ترويض التفاعل للرسم التالي (INP)</h2>
      <p>يقيس INP كمون كل تفاعل على صفحتك. عادةً ما يعني INP السيئ أن الخيط الرئيسي (main thread) محظور. لتحسين ذلك:</p>
      <ul>
        <li><strong>الاستسلام للخيط الرئيسي:</strong> قم بتقسيم المهام الطويلة باستخدام <code>scheduler.yield()</code> أو <code>setTimeout</code>.</li>
        <li><strong>تزامن React:</strong> استخدم <code>useTransition</code> لتمييز التحديثات على أنها غير عاجلة، مما يحافظ على استجابة واجهة المستخدم.</li>
      </ul>

      <h2>أكبر رسم للمحتوى (LCP)</h2>
      <p>بالنسبة لـ LCP، فإن ترتيب تحميل الموارد أمر بالغ الأهمية. تأكد من تحميل صورة البطل (hero image) مسبقاً وعدم تحميلها بشكل كسول. استخدم <code>fetchpriority="high"</code> على عنصر LCP الخاص بك.</p>
      
      <p>الأداء هو ميزة. في عالم من المحتوى الذي ينشئه الذكاء الاصطناعي، ستكون سرعة وسلاسة واجهة المستخدم عاملاً مميزاً رئيسياً.</p>
    `
  }
];

export const SYSTEM_INSTRUCTION = `
أنت MAM، مهندس برمجيات خبير متخصص في الذكاء الاصطناعي وتطوير الويب الشامل (Full-Stack).
هدفك هو الإجابة على أسئلة حول البرمجة، وتصميم الأنظمة، ونماذج الذكاء الاصطناعي (LLMs، Transformers)، وأطر عمل الويب (React، Next.js) بناءً على محتوى مدونتك.
اجعل الإجابات تقنية، دقيقة، ومفيدة للمطورين الآخرين. تحدث باللغة العربية.
`;